import"clsx";import j from"dexie";import{v4 as x}from"uuid";import{g as p,c as L,v as k,l as _}from"./settings.svelte.js";import"@sveltejs/kit/internal";import{w as $}from"./exports.js";import"./utils.js";import"@sveltejs/kit/internal/server";import{a5 as T,M as E,P as W}from"./index.js";function z(){const{set:h,subscribe:e}=$(!1);return{subscribe:e,check:async()=>!1}}const q=T.toString().includes("$$")||/function \w+\(\) \{\}/.test(T.toString());q&&new URL("https://example.com");const _e={updated:z()};function F(h,e={}){throw new Error("Cannot call goto(...) on the server")}const Ne=globalThis.Set,R=globalThis.Map;class Ie{current;constructor(e,t=!1){this.current=t}}function Le(h){return()=>{}}function b(h,e,t=!1){const s=[],i=new Map;for(const o of h)i.set(o.id,o);let n=i.get(e);if(!n){let o=-1;for(const c of h)c.timestamp>o&&(n=c,o=c.timestamp)}let a=n;for(;a&&((a.type!=="root"||t)&&s.push(a),a.parent!==null);)a=i.get(a.parent);return s.sort((o,c)=>o.timestamp-c.timestamp),s}function N(h,e){const t=new Map;for(const i of h)t.set(i.id,i);let s=t.get(e);for(;s&&s.children.length>0;){const i=s.children[s.children.length-1];s=t.get(i)}return s?.id??e}function U(h,e){const t=new Map;for(const n of h)t.set(n.id,n);const s=[],i=[e];for(;i.length>0;){const n=i.shift(),a=t.get(n);if(a)for(const o of a.children)s.push(o),i.push(o)}return s}function ke(h,e){const t=new Map;for(const c of h)t.set(c.id,c);const s=t.get(e);if(!s)return null;if(s.parent===null)return{message:s,siblingIds:[e],currentIndex:0,totalSiblings:1};const i=t.get(s.parent);if(!i)return{message:s,siblingIds:[e],currentIndex:0,totalSiblings:1};const n=i.children,a=n.map(c=>N(h,c)),o=n.indexOf(e);return{message:s,siblingIds:a,currentIndex:o,totalSiblings:n.length}}class J extends j{conversations;messages;constructor(){super("DeltaWebui"),this.version(1).stores({conversations:"id, lastModified, currNode, name",messages:"id, convId, type, role, timestamp, parent, children"})}}const l=new J;class r{static async addMessage(e){const t={...e,id:x()};return await l.messages.add(t),t}static async createConversation(e){const t={id:x(),name:e,lastModified:Date.now(),currNode:""};return await l.conversations.add(t),t}static async createMessageBranch(e,t){return await l.transaction("rw",[l.conversations,l.messages],async()=>{if(t!==null&&!await l.messages.get(t))throw new Error(`Parent message ${t} not found`);const s={...e,id:x(),parent:t,children:[]};if(await l.messages.add(s),t!==null){const i=await l.messages.get(t);i&&await l.messages.update(t,{children:[...i.children,s.id]})}return await this.updateConversation(e.convId,{currNode:s.id}),s})}static async createRootMessage(e){const t={id:x(),convId:e,type:"root",timestamp:Date.now(),role:"system",content:"",parent:null,thinking:"",children:[]};return await l.messages.add(t),t.id}static async deleteConversation(e){await l.transaction("rw",[l.conversations,l.messages],async()=>{await l.conversations.delete(e),await l.messages.where("convId").equals(e).delete()})}static async deleteMessage(e){await l.transaction("rw",l.messages,async()=>{const t=await l.messages.get(e);if(t){if(t.parent){const s=await l.messages.get(t.parent);s&&(s.children=s.children.filter(i=>i!==e),await l.messages.put(s))}await l.messages.delete(e)}})}static async deleteMessageCascading(e,t){return await l.transaction("rw",l.messages,async()=>{const s=await l.messages.where("convId").equals(e).toArray(),i=U(s,t),n=[t,...i],a=await l.messages.get(t);if(a&&a.parent){const o=await l.messages.get(a.parent);o&&(o.children=o.children.filter(c=>c!==t),await l.messages.put(o))}return await l.messages.bulkDelete(n),n})}static async getAllConversations(){return await l.conversations.orderBy("lastModified").reverse().toArray()}static async getConversation(e){return await l.conversations.get(e)}static async getConversationLeafNodes(e){return(await this.getConversationMessages(e)).filter(s=>s.children.length===0).map(s=>s.id)}static async getConversationMessages(e){return await l.messages.where("convId").equals(e).sortBy("timestamp")}static async getConversationPath(e){const t=await this.getConversation(e);if(!t)return[];const s=await this.getConversationMessages(e);if(s.length===0)return[];const i=t.currNode||s.reduce((n,a)=>a.timestamp>n.timestamp?a:n).id;return b(s,i,!1)}static async updateConversation(e,t){await l.conversations.update(e,{...t,lastModified:Date.now()})}static async updateCurrentNode(e,t){await this.updateConversation(e,{currNode:t})}static async updateMessage(e,t){await l.messages.update(e,t)}static async importConversations(e){let t=0,s=0;return await l.transaction("rw",[l.conversations,l.messages],async()=>{for(const i of e){const{conv:n,messages:a}=i;if(await l.conversations.get(n.id)){console.warn(`Conversation "${n.name}" already exists, skipping...`),s++;continue}await l.conversations.add(n);for(const c of a)await l.messages.put(c);t++}return{imported:t,skipped:s}})}}function G(h){const e=h.trim();if(!e)return"";const i=e.split(/[\\/]/).pop()?.trim();return i&&i.length>0?i:e}function De(...h){return h.filter(Boolean).join(" ")}const H=typeof document<"u";let P=0;class V{toasts=[];heights=[];#e=e=>{const t=this.toasts.findIndex(s=>s.id===e);return t===-1?null:t};addToast=e=>{H&&this.toasts.unshift(e)};updateToast=({id:e,data:t,type:s,message:i})=>{const n=this.toasts.findIndex(o=>o.id===e),a=this.toasts[n];this.toasts[n]={...a,...t,id:e,title:i,type:s,updated:!0}};create=e=>{const{message:t,...s}=e,i=typeof e?.id=="number"||e.id&&e.id?.length>0?e.id:P++,n=e.dismissable===void 0?!0:e.dismissable,a=e.type===void 0?"default":e.type;return E(()=>{this.toasts.find(c=>c.id===i)?this.updateToast({id:i,data:e,type:a,message:t,dismissable:n}):this.addToast({...s,id:i,title:t,dismissable:n,type:a})}),i};dismiss=e=>(E(()=>{if(e===void 0){this.toasts=this.toasts.map(s=>({...s,dismiss:!0}));return}const t=this.toasts.findIndex(s=>s.id===e);this.toasts[t]&&(this.toasts[t]={...this.toasts[t],dismiss:!0})}),e);remove=e=>{if(e===void 0){this.toasts=[];return}const t=this.#e(e);if(t!==null)return this.toasts.splice(t,1),e};message=(e,t)=>this.create({...t,type:"default",message:e});error=(e,t)=>this.create({...t,type:"error",message:e});success=(e,t)=>this.create({...t,type:"success",message:e});info=(e,t)=>this.create({...t,type:"info",message:e});warning=(e,t)=>this.create({...t,type:"warning",message:e});loading=(e,t)=>this.create({...t,type:"loading",message:e});promise=(e,t)=>{if(!t)return;let s;t.loading!==void 0&&(s=this.create({...t,promise:e,type:"loading",message:typeof t.loading=="string"?t.loading:t.loading()}));const i=e instanceof Promise?e:e();let n=s!==void 0;return i.then(a=>{if(typeof a=="object"&&a&&"ok"in a&&typeof a.ok=="boolean"&&!a.ok){n=!1;const o=K(a);this.create({id:s,type:"error",message:o})}else if(t.success!==void 0){n=!1;const o=typeof t.success=="function"?t.success(a):t.success;this.create({id:s,type:"success",message:o})}}).catch(a=>{if(t.error!==void 0){n=!1;const o=typeof t.error=="function"?t.error(a):t.error;this.create({id:s,type:"error",message:o})}}).finally(()=>{n&&(this.dismiss(s),s=void 0),t.finally?.()}),s};custom=(e,t)=>{const s=t?.id||P++;return this.create({component:e,id:s,...t}),s};removeHeight=e=>{this.heights=this.heights.filter(t=>t.toastId!==e)};setHeight=e=>{const t=this.#e(e.toastId);if(t===null){this.heights.push(e);return}this.heights[t]=e};reset=()=>{this.toasts=[],this.heights=[]}}function K(h){return h&&typeof h=="object"&&"status"in h?`HTTP error! Status: ${h.status}`:`Error! ${h}`}const w=new V;function Q(h,e){return w.create({message:h,...e})}class Ae{#e=W(()=>w.toasts.filter(e=>!e.dismiss));get toasts(){return this.#e()}}const X=Q,D=Object.assign(X,{success:w.success,info:w.info,warning:w.warning,error:w.error,custom:w.custom,message:w.message,promise:w.promise,dismiss:w.dismiss,loading:w.loading,getActiveToasts:()=>w.toasts.filter(h=>!h.dismiss)});class Y{activeConversation=null;activeMessages=[];conversations=[];currentResponse="";errorDialogState=null;isInitialized=!1;isLoading=!1;conversationLoadingStates=new R;conversationStreamingStates=new R;titleUpdateConfirmationCallback;constructor(){}async initialize(){try{await this.loadConversations(),this.isInitialized=!0}catch(e){console.error("Failed to initialize chat store:",e)}}async loadConversations(){this.conversations=await r.getAllConversations()}async createConversation(e){const t=e||`Chat ${new Date().toLocaleString()}`,s=await r.createConversation(t);this.conversations.unshift(s),this.activeConversation=s,this.activeMessages=[],p.setActiveConversation(s.id);const i=this.isConversationLoading(s.id);return this.isLoading=i,this.currentResponse="",await F(`#/chat/${s.id}`),s.id}async loadConversation(e){try{const t=await r.getConversation(e);if(!t)return!1;this.activeConversation=t,p.setActiveConversation(e);const s=this.isConversationLoading(e);this.isLoading=s;const i=this.getConversationStreaming(e);if(this.currentResponse=i?.response||"",t.currNode){const n=await r.getConversationMessages(e);this.activeMessages=b(n,t.currNode,!1)}else this.activeMessages=await r.getConversationMessages(e);return!0}catch(t){return console.error("Failed to load conversation:",t),!1}}async addMessage(e,t,s="text",i="-1",n){if(!this.activeConversation)return console.error("No active conversation when trying to add message"),null;try{let a=null;if(i==="-1")if(this.activeMessages.length>0)a=this.activeMessages[this.activeMessages.length-1].id;else{const v=(await r.getConversationMessages(this.activeConversation.id)).find(g=>g.parent===null&&g.type==="root");v?a=v.id:a=await r.createRootMessage(this.activeConversation.id)}else a=i;const o=await r.createMessageBranch({convId:this.activeConversation.id,role:e,content:t,type:s,timestamp:Date.now(),thinking:"",children:[],extra:n},a);return this.activeMessages.push(o),await r.updateCurrentNode(this.activeConversation.id,o.id),this.activeConversation.currNode=o.id,this.updateConversationTimestamp(),o}catch(a){return console.error("Failed to add message:",a),null}}getApiOptions(){const e=L(),t=i=>i!=null&&i!=="",s={stream:!0,timings_per_token:!0};return t(e.temperature)&&(s.temperature=Number(e.temperature)),t(e.max_tokens)&&(s.max_tokens=Number(e.max_tokens)),t(e.dynatemp_range)&&(s.dynatemp_range=Number(e.dynatemp_range)),t(e.dynatemp_exponent)&&(s.dynatemp_exponent=Number(e.dynatemp_exponent)),t(e.top_k)&&(s.top_k=Number(e.top_k)),t(e.top_p)&&(s.top_p=Number(e.top_p)),t(e.min_p)&&(s.min_p=Number(e.min_p)),t(e.xtc_probability)&&(s.xtc_probability=Number(e.xtc_probability)),t(e.xtc_threshold)&&(s.xtc_threshold=Number(e.xtc_threshold)),t(e.typ_p)&&(s.typ_p=Number(e.typ_p)),t(e.repeat_last_n)&&(s.repeat_last_n=Number(e.repeat_last_n)),t(e.repeat_penalty)&&(s.repeat_penalty=Number(e.repeat_penalty)),t(e.presence_penalty)&&(s.presence_penalty=Number(e.presence_penalty)),t(e.frequency_penalty)&&(s.frequency_penalty=Number(e.frequency_penalty)),t(e.dry_multiplier)&&(s.dry_multiplier=Number(e.dry_multiplier)),t(e.dry_base)&&(s.dry_base=Number(e.dry_base)),t(e.dry_allowed_length)&&(s.dry_allowed_length=Number(e.dry_allowed_length)),t(e.dry_penalty_last_n)&&(s.dry_penalty_last_n=Number(e.dry_penalty_last_n)),e.samplers&&(s.samplers=e.samplers),e.custom&&(s.custom=e.custom),s}setConversationLoading(e,t){t?(this.conversationLoadingStates.set(e,!0),this.activeConversation?.id===e&&(this.isLoading=!0)):(this.conversationLoadingStates.delete(e),this.activeConversation?.id===e&&(this.isLoading=!1))}isConversationLoading(e){return this.conversationLoadingStates.get(e)||!1}setConversationStreaming(e,t,s){this.conversationStreamingStates.set(e,{response:t,messageId:s}),this.activeConversation?.id===e&&(this.currentResponse=t)}clearConversationStreaming(e){this.conversationStreamingStates.delete(e),this.activeConversation?.id===e&&(this.currentResponse="")}getConversationStreaming(e){return this.conversationStreamingStates.get(e)}async streamChatCompletion(e,t,s,i){let n="",a="",o=null,c=!1;const g=!L().modelSelectorEnabled;let f=!1,I=null;const O=()=>{if(f)return;f=!0;const u=_.serverProps!==null;_.fetchServerProps({silent:u}).then(()=>{I?.(!0)}).catch(m=>{console.warn("Failed to refresh server props after streaming started:",m)})},A=(u,m=!0)=>{const y=_.modelName,C=g?y??u??null:u??y??null;if(!C)return;const M=G(C);if(!M||M===o)return;o=M;const S=this.findMessageIndex(t.id);this.updateMessageAtIndex(S,{model:M}),m&&!c&&(c=!0,r.updateMessage(t.id,{model:M}).catch(B=>{console.error("Failed to persist model name:",B),c=!1,o=null}))};g&&(I=(u=!0)=>{const m=_.modelName;m&&A(m,u)},I(!1)),p.startStreaming(),p.setActiveConversation(t.convId),await k.sendMessage(e,{...this.getApiOptions(),onFirstValidChunk:()=>{O()},onChunk:u=>{n+=u,this.setConversationStreaming(t.convId,n,t.id);const m=this.findMessageIndex(t.id);this.updateMessageAtIndex(m,{content:n})},onReasoningChunk:u=>{a+=u;const m=this.findMessageIndex(t.id);this.updateMessageAtIndex(m,{thinking:a})},onModel:u=>{A(u)},onComplete:async(u,m,y)=>{p.stopStreaming();const C={content:u||n,thinking:m||a,timings:y};o&&!c&&(C.model=o,c=!0),await r.updateMessage(t.id,C);const M=this.findMessageIndex(t.id),S={timings:y};C.model&&(S.model=C.model),this.updateMessageAtIndex(M,S),await r.updateCurrentNode(t.convId,t.id),this.activeConversation?.id===t.convId&&(this.activeConversation.currNode=t.id,await this.refreshActiveMessages()),s&&await s(n),this.setConversationLoading(t.convId,!1),this.clearConversationStreaming(t.convId),p.clearConversationState(t.convId)},onError:u=>{if(p.stopStreaming(),this.isAbortError(u)){this.setConversationLoading(t.convId,!1),this.clearConversationStreaming(t.convId),p.clearConversationState(t.convId);return}console.error("Streaming error:",u),this.setConversationLoading(t.convId,!1),this.clearConversationStreaming(t.convId),p.clearConversationState(t.convId);const m=this.activeMessages.findIndex(C=>C.id===t.id);if(m!==-1){const[C]=this.activeMessages.splice(m,1);C&&r.deleteMessage(C.id).catch(M=>{console.error("Failed to remove assistant message after error:",M)})}const y=u.name==="TimeoutError"?"timeout":"server";this.showErrorDialog(y,u.message),i&&i(u)}},t.convId)}isAbortError(e){return e instanceof Error&&(e.name==="AbortError"||e instanceof DOMException)}showErrorDialog(e,t){this.errorDialogState={type:e,message:t}}dismissErrorDialog(){this.errorDialogState=null}findMessageIndex(e){return this.activeMessages.findIndex(t=>t.id===e)}updateMessageAtIndex(e,t){e!==-1&&Object.assign(this.activeMessages[e],t)}async createAssistantMessage(e){return this.activeConversation?await r.createMessageBranch({convId:this.activeConversation.id,type:"text",role:"assistant",content:"",timestamp:Date.now(),thinking:"",children:[],model:null},e||null):null}updateConversationTimestamp(){if(!this.activeConversation)return;const e=this.conversations.findIndex(t=>t.id===this.activeConversation.id);if(e!==-1){this.conversations[e].lastModified=Date.now();const t=this.conversations.splice(e,1)[0];this.conversations.unshift(t)}}async sendMessage(e,t){if(!e.trim()&&(!t||t.length===0))return;if(this.activeConversation&&this.isConversationLoading(this.activeConversation.id)){console.log("Cannot send message: current conversation is already processing a message");return}let s=!1;if(this.activeConversation||(await this.createConversation(),s=!0),!this.activeConversation){console.error("No active conversation available for sending message");return}this.errorDialogState=null,this.setConversationLoading(this.activeConversation.id,!0),this.clearConversationStreaming(this.activeConversation.id);let i=null;try{if(i=await this.addMessage("user",e,"text","-1",t),!i)throw new Error("Failed to add user message");if(s&&e){const o=e.trim();await this.updateConversationName(this.activeConversation.id,o)}const n=await this.createAssistantMessage(i.id);if(!n)throw new Error("Failed to create assistant message");this.activeMessages.push(n);const a=this.activeMessages.slice(0,-1);await this.streamChatCompletion(a,n)}catch(n){if(this.isAbortError(n)){this.setConversationLoading(this.activeConversation.id,!1);return}if(console.error("Failed to send message:",n),this.setConversationLoading(this.activeConversation.id,!1),!this.errorDialogState)if(n instanceof Error){const a=n.name==="TimeoutError"?"timeout":"server";this.showErrorDialog(a,n.message)}else this.showErrorDialog("server","Unknown error occurred while sending message")}}async stopGeneration(){if(!this.activeConversation)return;const e=this.activeConversation.id;await this.savePartialResponseIfNeeded(e),p.stopStreaming(),k.abort(e),this.setConversationLoading(e,!1),this.clearConversationStreaming(e),p.clearConversationState(e)}async gracefulStop(){this.isLoading&&(p.stopStreaming(),k.abort(),await this.savePartialResponseIfNeeded(),this.conversationLoadingStates.clear(),this.conversationStreamingStates.clear(),this.isLoading=!1,this.currentResponse="")}async savePartialResponseIfNeeded(e){const t=e||this.activeConversation?.id;if(!t)return;const s=this.conversationStreamingStates.get(t);if(!s||!s.response.trim())return;const i=t===this.activeConversation?.id?this.activeMessages:await r.getConversationMessages(t);if(!i.length)return;const n=i[i.length-1];if(n&&n.role==="assistant")try{const a={content:s.response};n.thinking?.trim()&&(a.thinking=n.thinking);const o=await p.getCurrentState();o&&(a.timings={prompt_n:o.promptTokens||0,predicted_n:o.tokensDecoded||0,cache_n:o.cacheTokens||0,predicted_ms:o.tokensPerSecond&&o.tokensDecoded?o.tokensDecoded/o.tokensPerSecond*1e3:void 0}),await r.updateMessage(n.id,a),n.content=this.currentResponse,a.thinking!==void 0&&(n.thinking=a.thinking),a.timings&&(n.timings=a.timings)}catch(a){n.content=this.currentResponse,console.error("Failed to save partial response:",a)}else console.error("Last message is not an assistant message")}async updateMessage(e,t){if(this.activeConversation){this.isLoading&&this.stopGeneration();try{const s=this.findMessageIndex(e);if(s===-1){console.error("Message not found for update");return}const i=this.activeMessages[s],n=i.content;if(i.role!=="user"){console.error("Only user messages can be edited");return}const o=(await r.getConversationMessages(this.activeConversation.id)).find(g=>g.type==="root"&&g.parent===null),c=o&&i.parent===o.id&&i.role==="user";this.updateMessageAtIndex(s,{content:t}),await r.updateMessage(e,{content:t}),c&&t.trim()&&await this.updateConversationTitleWithConfirmation(this.activeConversation.id,t.trim(),this.titleUpdateConfirmationCallback);const v=this.activeMessages.slice(s+1);for(const g of v)await r.deleteMessage(g.id);this.activeMessages=this.activeMessages.slice(0,s+1),this.updateConversationTimestamp(),this.setConversationLoading(this.activeConversation.id,!0),this.clearConversationStreaming(this.activeConversation.id);try{const g=await this.createAssistantMessage();if(!g)throw new Error("Failed to create assistant message");this.activeMessages.push(g),await r.updateCurrentNode(this.activeConversation.id,g.id),this.activeConversation.currNode=g.id,await this.streamChatCompletion(this.activeMessages.slice(0,-1),g,void 0,()=>{const f=this.findMessageIndex(e);this.updateMessageAtIndex(f,{content:n})})}catch(g){console.error("Failed to regenerate response:",g),this.setConversationLoading(this.activeConversation.id,!1);const f=this.findMessageIndex(e);this.updateMessageAtIndex(f,{content:n})}}catch(s){if(this.isAbortError(s))return;console.error("Failed to update message:",s)}}}async regenerateMessage(e){if(!(!this.activeConversation||this.isLoading))try{const t=this.findMessageIndex(e);if(t===-1){console.error("Message not found for regeneration");return}if(this.activeMessages[t].role!=="assistant"){console.error("Only assistant messages can be regenerated");return}const i=this.activeMessages.slice(t);for(const n of i)await r.deleteMessage(n.id);this.activeMessages=this.activeMessages.slice(0,t),this.updateConversationTimestamp(),this.setConversationLoading(this.activeConversation.id,!0),this.clearConversationStreaming(this.activeConversation.id);try{const n=this.activeMessages.length>0?this.activeMessages[this.activeMessages.length-1].id:null,a=await this.createAssistantMessage(n);if(!a)throw new Error("Failed to create assistant message");this.activeMessages.push(a);const o=this.activeMessages.slice(0,-1);await this.streamChatCompletion(o,a)}catch(n){console.error("Failed to regenerate response:",n),this.setConversationLoading(this.activeConversation.id,!1)}}catch(t){if(this.isAbortError(t))return;console.error("Failed to regenerate message:",t)}}async updateConversationName(e,t){try{await r.updateConversation(e,{name:t});const s=this.conversations.findIndex(i=>i.id===e);s!==-1&&(this.conversations[s].name=t),this.activeConversation?.id===e&&(this.activeConversation.name=t)}catch(s){console.error("Failed to update conversation name:",s)}}setTitleUpdateConfirmationCallback(e){this.titleUpdateConfirmationCallback=e}async updateConversationTitleWithConfirmation(e,t,s){try{if(L().askForTitleConfirmation&&s){const n=await r.getConversation(e);if(!n||!await s(n.name,t))return!1}return await this.updateConversationName(e,t),!0}catch(i){return console.error("Failed to update conversation title with confirmation:",i),!1}}async downloadConversation(e){if(!this.activeConversation||this.activeConversation.id!==e){const t=await r.getConversation(e);if(!t)return;const s=await r.getConversationMessages(e),i={conv:t,messages:s};this.triggerDownload(i)}else{const t={conv:this.activeConversation,messages:this.activeMessages};this.triggerDownload(t)}}triggerDownload(e,t){const s="conv"in e?e.conv:Array.isArray(e)?e[0]?.conv:void 0;if(!s){console.error("Invalid data: missing conversation");return}const i=s.name?s.name.trim():"",n=s.id||"unknown",a=i.toLowerCase().replace(/[^a-z0-9]/gi,"_").replace(/_+/g,"_").substring(0,20),o=t||`conversation_${n}_${a}.json`,c=JSON.stringify(e,null,2),v=new Blob([c],{type:"application/json"}),g=URL.createObjectURL(v),f=document.createElement("a");f.href=g,f.download=o,document.body.appendChild(f),f.click(),document.body.removeChild(f),URL.revokeObjectURL(g)}async exportAllConversations(){try{const e=await r.getAllConversations();if(e.length===0)throw new Error("No conversations to export");const t=await Promise.all(e.map(async a=>{const o=await r.getConversationMessages(a.id);return{conv:a,messages:o}})),s=new Blob([JSON.stringify(t,null,2)],{type:"application/json"}),i=URL.createObjectURL(s),n=document.createElement("a");return n.href=i,n.download=`all_conversations_${new Date().toISOString().split("T")[0]}.json`,document.body.appendChild(n),n.click(),document.body.removeChild(n),URL.revokeObjectURL(i),D.success(`All conversations (${e.length}) prepared for download`),e}catch(e){throw console.error("Failed to export conversations:",e),e}}async importConversations(){return new Promise((e,t)=>{const s=document.createElement("input");s.type="file",s.accept=".json",s.onchange=async i=>{const n=i.target?.files?.[0];if(!n){t(new Error("No file selected"));return}try{const a=await n.text(),o=JSON.parse(a);let c;if(Array.isArray(o))c=o;else if(o&&typeof o=="object"&&"conv"in o&&"messages"in o)c=[o];else throw new Error("Invalid file format: expected array of conversations or single conversation object");const v=await r.importConversations(c);await this.loadConversations(),D.success(`Imported ${v.imported} conversation(s), skipped ${v.skipped}`);const g=c.map(f=>f.conv);e(g)}catch(a){const o=a instanceof Error?a.message:"Unknown error";console.error("Failed to import conversations:",a),D.error("Import failed",{description:o}),t(new Error(`Import failed: ${o}`))}},s.click()})}async deleteConversation(e){try{await r.deleteConversation(e),this.conversations=this.conversations.filter(t=>t.id!==e),this.activeConversation?.id===e&&(this.activeConversation=null,this.activeMessages=[],await F("?new_chat=true#/"))}catch(t){console.error("Failed to delete conversation:",t)}}async getDeletionInfo(e){if(!this.activeConversation)return{totalCount:0,userMessages:0,assistantMessages:0,messageTypes:[]};const t=await r.getConversationMessages(this.activeConversation.id),s=U(t,e),i=[e,...s],n=t.filter(v=>i.includes(v.id));let a=0,o=0;const c=[];for(const v of n)v.role==="user"?(a++,c.includes("user message")||c.push("user message")):v.role==="assistant"&&(o++,c.includes("assistant response")||c.push("assistant response"));return{totalCount:i.length,userMessages:a,assistantMessages:o,messageTypes:c}}async deleteMessage(e){try{if(!this.activeConversation)return;const t=await r.getConversationMessages(this.activeConversation.id),s=t.find(a=>a.id===e);if(!s){console.error("Message to delete not found");return}if(b(t,this.activeConversation.currNode||"",!1).some(a=>a.id===e)&&s.parent){const a=t.filter(o=>o.parent===s.parent&&o.id!==e);if(a.length>0){const o=a.reduce((v,g)=>g.timestamp>v.timestamp?g:v),c=N(t,o.id);await r.updateCurrentNode(this.activeConversation.id,c),this.activeConversation.currNode=c}else if(s.parent){const o=N(t,s.parent);await r.updateCurrentNode(this.activeConversation.id,o),this.activeConversation.currNode=o}}await r.deleteMessageCascading(this.activeConversation.id,e),await this.refreshActiveMessages(),this.updateConversationTimestamp()}catch(t){console.error("Failed to delete message:",t)}}clearActiveConversation(){this.activeConversation=null,this.activeMessages=[],this.isLoading=!1,this.currentResponse="",p.setActiveConversation(null)}async refreshActiveMessages(){if(!this.activeConversation)return;const e=await r.getConversationMessages(this.activeConversation.id);if(e.length===0){this.activeMessages=[];return}const t=this.activeConversation.currNode||e.reduce((i,n)=>n.timestamp>i.timestamp?n:i).id,s=b(e,t,!1);this.activeMessages.length=0,this.activeMessages.push(...s)}async navigateToSibling(e){if(!this.activeConversation)return;const t=await r.getConversationMessages(this.activeConversation.id),s=t.find(a=>a.type==="root"&&a.parent===null),i=this.activeMessages.find(a=>a.role==="user"&&a.parent===s?.id),n=N(t,e);if(await r.updateCurrentNode(this.activeConversation.id,n),this.activeConversation.currNode=n,await this.refreshActiveMessages(),s&&this.activeMessages.length>0){const a=this.activeMessages.find(o=>o.role==="user"&&o.parent===s.id);a&&a.content.trim()&&(!i||a.id!==i.id||a.content.trim()!==i.content.trim())&&await this.updateConversationTitleWithConfirmation(this.activeConversation.id,a.content.trim(),this.titleUpdateConfirmationCallback)}}async editAssistantMessage(e,t,s){if(!(!this.activeConversation||this.isLoading))try{const i=this.findMessageIndex(e);if(i===-1){console.error("Message not found for editing");return}const n=this.activeMessages[i];if(n.role!=="assistant"){console.error("Only assistant messages can be edited with this method");return}if(s){const a=await r.createMessageBranch({convId:n.convId,type:n.type,timestamp:Date.now(),role:n.role,content:t,thinking:n.thinking||"",children:[],model:n.model},n.parent);await r.updateCurrentNode(this.activeConversation.id,a.id),this.activeConversation.currNode=a.id}else await r.updateMessage(n.id,{content:t,timestamp:Date.now()}),this.updateMessageAtIndex(i,{content:t,timestamp:Date.now()});this.updateConversationTimestamp(),await this.refreshActiveMessages()}catch(i){console.error("Failed to edit assistant message:",i)}}async editMessageWithBranching(e,t){if(!(!this.activeConversation||this.isLoading))try{const s=this.findMessageIndex(e);if(s===-1){console.error("Message not found for editing");return}const i=this.activeMessages[s];if(i.role!=="user"){console.error("Only user messages can be edited");return}const n=await r.getConversationMessages(this.activeConversation.id),a=n.find(g=>g.type==="root"&&g.parent===null),o=a&&i.parent===a.id&&i.role==="user";let c=i.parent;if(c==null){const g=n.find(f=>f.type==="root"&&f.parent===null);if(g)c=g.id;else{console.error("No root message found for editing");return}}const v=await r.createMessageBranch({convId:i.convId,type:i.type,timestamp:Date.now(),role:i.role,content:t,thinking:i.thinking||"",children:[],extra:i.extra?JSON.parse(JSON.stringify(i.extra)):void 0,model:i.model},c);await r.updateCurrentNode(this.activeConversation.id,v.id),this.activeConversation.currNode=v.id,this.updateConversationTimestamp(),o&&t.trim()&&await this.updateConversationTitleWithConfirmation(this.activeConversation.id,t.trim(),this.titleUpdateConfirmationCallback),await this.refreshActiveMessages(),i.role==="user"&&await this.generateResponseForMessage(v.id)}catch(s){console.error("Failed to edit message with branching:",s)}}async regenerateMessageWithBranching(e){if(!(!this.activeConversation||this.isLoading))try{const t=this.findMessageIndex(e);if(t===-1){console.error("Message not found for regeneration");return}const s=this.activeMessages[t];if(s.role!=="assistant"){console.error("Only assistant messages can be regenerated");return}const n=(await r.getConversationMessages(this.activeConversation.id)).find(v=>v.id===s.parent);if(!n){console.error("Parent message not found for regeneration");return}this.setConversationLoading(this.activeConversation.id,!0),this.clearConversationStreaming(this.activeConversation.id);const a=await r.createMessageBranch({convId:this.activeConversation.id,type:"text",timestamp:Date.now(),role:"assistant",content:"",thinking:"",children:[],model:null},n.id);await r.updateCurrentNode(this.activeConversation.id,a.id),this.activeConversation.currNode=a.id,this.updateConversationTimestamp(),await this.refreshActiveMessages();const o=await r.getConversationMessages(this.activeConversation.id),c=b(o,n.id,!1);await this.streamChatCompletion(c,a)}catch(t){if(this.isAbortError(t))return;console.error("Failed to regenerate message with branching:",t),this.setConversationLoading(this.activeConversation.id,!1)}}async generateResponseForMessage(e){if(this.activeConversation){this.errorDialogState=null,this.setConversationLoading(this.activeConversation.id,!0),this.clearConversationStreaming(this.activeConversation.id);try{const t=await r.getConversationMessages(this.activeConversation.id),s=b(t,e,!1),i=await r.createMessageBranch({convId:this.activeConversation.id,type:"text",timestamp:Date.now(),role:"assistant",content:"",thinking:"",children:[],model:null},e);this.activeMessages.push(i),await this.streamChatCompletion(s,i)}catch(t){console.error("Failed to generate response:",t),this.setConversationLoading(this.activeConversation.id,!1)}}}isConversationLoadingPublic(e){return this.isConversationLoading(e)}getConversationStreamingPublic(e){return this.getConversationStreaming(e)}getAllLoadingConversations(){return Array.from(this.conversationLoadingStates.keys())}getAllStreamingConversations(){return Array.from(this.conversationStreamingStates.keys())}}const d=new Y,Z=()=>d.conversations,ee=()=>d.activeConversation,te=()=>d.activeMessages,se=()=>d.isLoading,ie=()=>d.errorDialogState;d.createConversation.bind(d);d.downloadConversation.bind(d);d.exportAllConversations.bind(d);d.importConversations.bind(d);const ne=d.deleteConversation.bind(d),ae=d.sendMessage.bind(d),oe=d.dismissErrorDialog.bind(d);d.gracefulStop.bind(d);d.refreshActiveMessages.bind(d);const re=d.navigateToSibling.bind(d),ce=d.editAssistantMessage.bind(d),de=d.editMessageWithBranching.bind(d),le=d.regenerateMessageWithBranching.bind(d),ge=d.deleteMessage.bind(d),he=d.getDeletionInfo.bind(d),ve=d.updateConversationName.bind(d);d.setTitleUpdateConfirmationCallback.bind(d);function ue(){d.stopGeneration()}const fe=()=>d.getAllLoadingConversations(),Te=Object.freeze(Object.defineProperty({__proto__:null,activeConversation:ee,activeMessages:te,chatStore:d,conversations:Z,deleteConversation:ne,deleteMessage:ge,dismissErrorDialog:oe,editAssistantMessage:ce,editMessageWithBranching:de,errorDialog:ie,getAllLoadingConversations:fe,getDeletionInfo:he,isLoading:se,navigateToSibling:re,regenerateMessageWithBranching:le,sendMessage:ae,stopGeneration:ue,updateConversationName:ve},Symbol.toStringTag,{value:"Module"}));export{R as A,Te as B,r as D,Ie as M,Ae as S,De as a,Z as b,Le as c,ne as d,te as e,F as f,fe as g,ee as h,se as i,D as j,he as k,ke as l,de as m,re as n,ce as o,ge as p,ie as q,le as r,ue as s,w as t,ve as u,ae as v,oe as w,Ne as x,d as y,_e as z};
